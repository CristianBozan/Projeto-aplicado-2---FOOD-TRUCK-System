Diagrama de Arquitetura - Projeto FoodTruck System

Este documento contém as descrições e representações (em texto/PlantUML) dos seguintes diagramas:
- Diagrama de Sequência
- Diagrama de Atividades
- Diagrama de Classes
- Diagrama de Componentes
- Diagrama de Implementação (Deployment)

Inclui também mapeamento entre elementos do diagrama e arquivos/camadas do projeto.

=================================================================
1) DIAGRAMA DE SEQUÊNCIA
Caso de uso: Criar Pedido (Fluxo principal)
Descrição: Cliente/Operador no frontend cria um pedido com itens. O servidor cria o pedido e os itens em transação e atualiza estoque.

PlantUML (sequência):
@startuml
actor Cliente
participant "Front-end (public)" as FE
participant "PedidoController (API)" as API
participant "Pedido Model" as Pedido
participant "ItemPedido Model" as Item
participant "Produto Model" as Produto
database "MySQL" as DB

Cliente -> FE : Preenche formulário e envia (POST /pedidos)
FE -> API : POST /pedidos {itens, total, id_atendente}
API -> API : Inicia transação
API -> Pedido : create(pedidoPayload)
Pedido -> DB : INSERT pedidos
API -> Item : create(itens) [loop]
Item -> DB : INSERT itens_pedido
API -> Produto : atualizar quantidade_estoque (decremento) [loop]
Produto -> DB : UPDATE produtos
API -> API : commit
API -> FE : 201 Created (pedido criado)
@enduml

Mapeamento para código:

Caso de uso: Gerar Backup Manual

PlantUML (sequência):
@startuml
actor Operador
participant "Front-end (UI Backups)" as FE
participant "BackupController (API)" as BackupAPI
participant "Backup Model" as Backup
participant "Venda/ Pedido / Produto Models" as Models
database "MySQL" as DB

Operador -> FE : Clica 'Gerar Backup'
FE -> BackupAPI : POST /backups { nome? }
BackupAPI -> Models : findAll(vendas, pedidos, itens, produtos)
Models -> DB : SELECT ...
BackupAPI -> Backup : create({nome, conteudo_json})
Backup -> DB : INSERT backups
BackupAPI -> FE : 201 Created {id_backup}
@enduml

=================================================================
2) DIAGRAMA DE ATIVIDADES
Atividade: Fluxo de restauração (modo: safe)
Descrição: Verifica existência dos registros, insere os ausentes e atualiza estoques quando aplicável.

PlantUML (atividade):
@startuml
start
:Receber request /backups/:id/restore;
:Carregar backup (conteudo_json);
if (mode == 'force'?) then (sim)
  :Apagar pedidos, itens e vendas atuais;
  :Recriar pedidos, itens e vendas;
  :Sobrescrever produtos (criar/atualizar) e gravar logs em `estoque_logs` (acao: create/update);
else (não)
  :Para cada pedido do backup;
  if (pedido existe?) then (sim)
    :pular;
  else (não)
    :criar pedido e itens;
  endif
  :Para cada venda do backup -> criar se ausente;
  :Para cada produto do backup -> se existe e estoque==0 então atualizar; ao atualizar gravar entrada em `estoque_logs` (acao: update, nota: 'restore safe');
endif
:Retornar relatório de resultado;
stop
@enduml

Observações rápidas:

=================================================================
3) DIAGRAMA DE CLASSES
Descrição: Principais entidades do domínio e atributos relevantes.

PlantUML (classes):
@startuml
class Produto {
  +id_produto: integer
  +nome: string
  +descricao: string
  +preco: decimal
  +quantidade_estoque: integer
  +status: string
}
class Pedido {
  +id_pedido: integer
  +data_hora: datetime
  +id_atendente: integer
  +id_mesa: integer
  +forma_pagamento: string
  +status: string
  +observacoes: string
  +total: decimal
}
class ItemPedido {
  +id_item: integer
  +id_pedido: integer
  +id_produto: integer
  +quantidade: integer
  +preco_unitario: decimal
  +subtotal: decimal
}
class Venda {
  +id_venda: integer
  +id_pedido: integer
  +data_hora: datetime
  +valor_total: decimal
  +forma_pagamento: string
}
class Atendente {
  +id_atendente: integer
  +nome: string
  +email: string
}
class Mesa {
  +id_mesa: integer
  +descricao: string
}
class Backup {
  +id_backup: integer
  +nome: string
  +conteudo_json: text
  +data_hora: datetime
}
class EstoqueLog {
  +id_estoque_log: integer
  +id_produto: integer
  +acao: string
  +quantidade_anterior: integer
  +quantidade_nova: integer
  +nota: string
  +data_hora: datetime
}

Pedido "1" -- "*" ItemPedido : possui
Produto "1" -- "*" ItemPedido : referenciado por
Pedido "1" -- "0..1" Venda : pode ter
Produto "1" -- "*" EstoqueLog : registra alterações
@enduml

Mapeamento para código (arquivos):

=================================================================
4) DIAGRAMA DE COMPONENTES
Descrição: Componentes de alto nível e suas responsabilidades.

Componentes principais (texto + PlantUML):
@startuml
package "Frontend" {
  [UI Estática] as UI
}
package "Backend API" {
  [Express Server] as API
  [Controllers] as Controllers
  [Services] as Services
  [Scheduler (node-cron)] as Scheduler
}
database "MySQL" as DB
[Excel Exporter (exceljs)] as Excel

UI --> API : HTTP (REST) requests
API --> Controllers : route handlers
Controllers --> Services : business logic (transactions)
Services --> DB : Sequelize queries
Scheduler --> Controllers : aciona createBackup()
Controllers --> Excel : gera .xlsx para download
@enduml

Onde no projeto:

=================================================================
5) DIAGRAMA DE IMPLEMENTAÇÃO (Deployment)
Descrição: Nós e artefatos para implantação típica.

PlantUML (deployment):
@startuml
node "Servidor de Aplicação (Node.js)" as AppNode {
  component "foodtruck-system (app)" as App
}
node "Servidor de Banco (MySQL)" as DBNode {
  database "MySQL" as DB
}
node "Armazenamento (opcional)" as Storage {
  folder "Backups (S3 / FS)" as Backups
}
AppNode --> DBNode : conexão MySQL (mysql2)
AppNode --> Storage : upload/download backups (opcional)

legend left
  Implementação típica:
  - App executando Node.js (processo / container)
  - Banco MySQL (instância gerenciada ou container)
  - Opcionalmente S3 para backups/arquivos grandes
endlegend
@enduml

Observações finais e recomendações

Fim do documento.
